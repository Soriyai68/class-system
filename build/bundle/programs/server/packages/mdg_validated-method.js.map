{"version":3,"sources":["meteor://ðŸ’»app/packages/mdg:validated-method/validated-method.js"],"names":["_objectSpread","module","link","default","v","export","ValidatedMethod","check","Match","__reifyWaitForDeps__","constructor","options","mixins","Function","name","String","applyMixins","connection","methods","Error","Meteor","validate","applyOptions","ObjectIncluding","run","Object","defaultApplyOptions","returnStubValue","throwStubExceptions","assign","method","args","Any","methodInvocation","_execute","call","callback","apply","err","callAsync","isClient","DDP","_CurrentMethodInvocation","_set","_setCallAsyncMethodRunning","Promise","resolve","reject","clientResultOrThenable","applyAsync","isFromCallAsync","serverResult","isThenable","then","catch","arguments","length","undefined","validateResult","bind","forEach","mixin","test","functionName","toString","match","msg","concat","__reify_async_result__","_reifyError","self","async"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;IAAA,IAAIA,aAAa;IAACC,MAAM,CAACC,IAAI,CAAC,sCAAsC,EAAC;MAACC,OAAOA,CAACC,CAAC,EAAC;QAACJ,aAAa,GAACI,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAArGH,MAAM,CAACI,MAAM,CAAC;MAACC,eAAe,EAACA,CAAA,KAAIA;IAAe,CAAC,CAAC;IAAC,IAAIC,KAAK,EAACC,KAAK;IAACP,MAAM,CAACC,IAAI,CAAC,cAAc,EAAC;MAACK,KAAKA,CAACH,CAAC,EAAC;QAACG,KAAK,GAACH,CAAC;MAAA,CAAC;MAACI,KAAKA,CAACJ,CAAC,EAAC;QAACI,KAAK,GAACJ,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAAC,IAAIK,oBAAoB,CAAC,CAAC,EAAE,CAAC,MAAMA,oBAAoB,CAAC,CAAC,EAAE,CAAC;IAE9L,MAAMH,eAAe,CAAC;MAC3BI,WAAWA,CAACC,OAAO,EAAE;QACnB;QACAA,OAAO,CAACC,MAAM,GAAGD,OAAO,CAACC,MAAM,IAAI,EAAE;QACrCL,KAAK,CAACI,OAAO,CAACC,MAAM,EAAE,CAACC,QAAQ,CAAC,CAAC;QACjCN,KAAK,CAACI,OAAO,CAACG,IAAI,EAAEC,MAAM,CAAC;QAC3BJ,OAAO,GAAGK,WAAW,CAACL,OAAO,EAAEA,OAAO,CAACC,MAAM,CAAC;QAE9C,IAAGD,OAAO,CAACM,UAAU,EAAE;UACrB;UACA,IAAG,OAAON,OAAO,CAACM,UAAU,KAAK,QAAQ,IACtC,CAACN,OAAO,CAACM,UAAU,CAACC,OAAO,EAAE,MAAM,IAAIC,KAAK,CAAC,yBAAyB,CAAC;QAC5E,CAAC,MAAM;UACL;UACA;UACAR,OAAO,CAACM,UAAU,GAAGG,MAAM;QAC7B;;QAEA;QACA,IAAIT,OAAO,CAACU,QAAQ,KAAK,IAAI,EAAE;UAC7BV,OAAO,CAACU,QAAQ,GAAG,YAAY,CAAC,CAAC;QACnC;;QAEA;QACAV,OAAO,CAACW,YAAY,GAAGX,OAAO,CAACW,YAAY,IAAI,CAAC,CAAC;QAEjDf,KAAK,CAACI,OAAO,EAAEH,KAAK,CAACe,eAAe,CAAC;UACnCT,IAAI,EAAEC,MAAM;UACZM,QAAQ,EAAER,QAAQ;UAClBW,GAAG,EAAEX,QAAQ;UACbD,MAAM,EAAE,CAACC,QAAQ,CAAC;UAClBS,YAAY,EAAEG;QAChB,CAAC,CAAC,CAAC;;QAEH;QACA,MAAMC,mBAAmB,GAAG;UAC1B;UACAC,eAAe,EAAE,IAAI;UAErB;UACA;UACAC,mBAAmB,EAAE;QACvB,CAAC;QAEDjB,OAAO,CAACW,YAAY,GAAAtB,aAAA,CAAAA,aAAA,KACf0B,mBAAmB,GACnBf,OAAO,CAACW,YAAY,CACxB;;QAED;QACAG,MAAM,CAACI,MAAM,CAAC,IAAI,EAAElB,OAAO,CAAC;QAE5B,MAAMmB,MAAM,GAAG,IAAI;QACnB,IAAI,CAACb,UAAU,CAACC,OAAO,CAAC;UACtB,CAACP,OAAO,CAACG,IAAI,EAAEiB,IAAI,EAAE;YACnB;YACAxB,KAAK,CAACwB,IAAI,EAAEvB,KAAK,CAACwB,GAAG,CAAC;YACtB,MAAMC,gBAAgB,GAAG,IAAI;YAE7B,OAAOH,MAAM,CAACI,QAAQ,CAACD,gBAAgB,EAAEF,IAAI,CAAC;UAChD;QACF,CAAC,CAAC;MACJ;MAEAI,IAAIA,CAACJ,IAAI,EAAEK,QAAQ,EAAE;QACnB;QACA,IAAK,OAAOL,IAAI,KAAK,UAAU,EAAG;UAChCK,QAAQ,GAAGL,IAAI;UACfA,IAAI,GAAG,CAAC,CAAC;QACX;QAEA,IAAI;UACF,OAAO,IAAI,CAACd,UAAU,CAACoB,KAAK,CAAC,IAAI,CAACvB,IAAI,EAAE,CAACiB,IAAI,CAAC,EAAE,IAAI,CAACT,YAAY,EAAEc,QAAQ,CAAC;QAC9E,CAAC,CAAC,OAAOE,GAAG,EAAE;UACZ,IAAIF,QAAQ,EAAE;YACZ;YACAA,QAAQ,CAACE,GAAG,CAAC;UACf,CAAC,MAAM;YACL;YACA;YACA,MAAMA,GAAG;UACX;QACF;MACF;MAEAC,SAASA,CAACR,IAAI,EAAE;QAChB;QACA;QACA;QACA,IAAIX,MAAM,CAACoB,QAAQ,EAAE;UACpBC,GAAG,CAACC,wBAAwB,CAACC,IAAI,CAAC,CAAC;UACnCF,GAAG,CAACC,wBAAwB,CAACE,0BAA0B,CAAC,IAAI,CAAC;UAE7D,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;YACvC,MAAMC,sBAAsB,GAAG,IAAI,CAAC/B,UAAU,CAACgC,UAAU,CACxD,IAAI,CAACnC,IAAI,EACT,CAACiB,IAAI,CAAC;cACN;cACA;cACA;cACA;cACAN,MAAM,CAACI,MAAM,CAAC,IAAI,CAACP,YAAY,EAAE;gBAAEM,mBAAmB,EAAE,IAAI;gBAAEsB,eAAe,EAAE;cAAK,CAAC,CAAC,EACtF,CAACZ,GAAG,EAAEa,YAAY,KAAK;gBACtB;gBACA;gBACA;gBACA;gBACA;gBACA;;gBAEAV,GAAG,CAACC,wBAAwB,CAACE,0BAA0B,CAAC,KAAK,CAAC;gBAE9D,IAAIN,GAAG,EAAES,MAAM,CAACT,GAAG,CAAC;gBACpBQ,OAAO,CAACK,YAAY,CAAC;cACtB,CACD,CAAC;cACDC,UAAU,GAAGJ,sBAAsB,IAAI,OAAOA,sBAAsB,CAACK,IAAI,KAAK,UAAU;;YAExF;YACA,IAAID,UAAU,EAAEJ,sBAAsB,CAACM,KAAK,CAAChB,GAAG,IAAIS,MAAM,CAACT,GAAG,CAAC,CAAC;UACjE,CAAC,CAAC;QACH;;QAEA;QACA,OAAO,IAAI,CAACrB,UAAU,CAACgC,UAAU,CAAC,IAAI,CAACnC,IAAI,EAAE,CAACiB,IAAI,CAAC,EAAE,IAAI,CAACT,YAAY,CAAC;MACvE;MAEAY,QAAQA,CAAA,EAA8B;QAAA,IAA7BD,gBAAgB,GAAAsB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;QAAA,IAAExB,IAAI,GAAAwB,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;QAClC;QACAxB,gBAAgB,CAACnB,IAAI,GAAG,IAAI,CAACA,IAAI;QAEjC,MAAM4C,cAAc,GAAG,IAAI,CAACrC,QAAQ,CAACsC,IAAI,CAAC1B,gBAAgB,CAAC,CAACF,IAAI,CAAC;QAEjE,IAAI,OAAO2B,cAAc,KAAK,WAAW,EAAE;UACzC,MAAM,IAAIvC,KAAK,oFACgB,CAAC;QAClC;QAEA,OAAO,IAAI,CAACK,GAAG,CAACmC,IAAI,CAAC1B,gBAAgB,CAAC,CAACF,IAAI,CAAC;MAC9C;IACF;IAAC;;IAED;IACA,SAASf,WAAWA,CAACe,IAAI,EAAEnB,MAAM,EAAE;MACjC;MACA,MAAM;QAAEE;MAAK,CAAC,GAAGiB,IAAI;MAErBnB,MAAM,CAACgD,OAAO,CAAEC,KAAK,IAAK;QACxB9B,IAAI,GAAG8B,KAAK,CAAC9B,IAAI,CAAC;QAElB,IAAG,CAACvB,KAAK,CAACsD,IAAI,CAAC/B,IAAI,EAAEN,MAAM,CAAC,EAAE;UAC5B,MAAMsC,YAAY,GAAGF,KAAK,CAACG,QAAQ,CAAC,CAAC,CAACC,KAAK,CAAC,iBAAiB,CAAC;UAC9D,IAAIC,GAAG,GAAG,mBAAmB;UAE7B,IAAGH,YAAY,EAAE;YACfG,GAAG,oBAAAC,MAAA,CAAoBJ,YAAY,CAAC,CAAC,CAAC,MAAG;UAC3C;UAEA,MAAM,IAAI5C,KAAK,aAAAgD,MAAA,CAAarD,IAAI,eAAAqD,MAAA,CAAYD,GAAG,uCAAoC,CAAC;QACtF;MACF,CAAC,CAAC;MAEF,OAAOnC,IAAI;IACb;IAACqC,sBAAA;EAAA,SAAAC,WAAA;IAAA,OAAAD,sBAAA,CAAAC,WAAA;EAAA;EAAAD,sBAAA;AAAA;EAAAE,IAAA;EAAAC,KAAA;AAAA,G","file":"/packages/mdg_validated-method.js","sourcesContent":["import { check, Match } from 'meteor/check';\n\nexport class ValidatedMethod {\n  constructor(options) {\n    // Default to no mixins\n    options.mixins = options.mixins || [];\n    check(options.mixins, [Function]);\n    check(options.name, String);\n    options = applyMixins(options, options.mixins);\n\n    if(options.connection) {\n      // Make sure we have a valid connection object\n      if(typeof options.connection !== 'object'\n      || !options.connection.methods) throw new Error('Invalid connection type');\n    } else {\n      // connection argument defaults to Meteor, which is where Methods are defined on client and\n      // server\n      options.connection = Meteor;\n    }\n\n    // Allow validate: null shorthand for methods that take no arguments\n    if (options.validate === null) {\n      options.validate = function () {};\n    }\n\n    // If this is null/undefined, make it an empty object\n    options.applyOptions = options.applyOptions || {};\n\n    check(options, Match.ObjectIncluding({\n      name: String,\n      validate: Function,\n      run: Function,\n      mixins: [Function],\n      applyOptions: Object,\n    }));\n\n    // Default options passed to Meteor.apply, can be overridden with applyOptions\n    const defaultApplyOptions = {\n      // Make it possible to get the ID of an inserted item\n      returnStubValue: true,\n\n      // Don't call the server method if the client stub throws an error, so that we don't end\n      // up doing validations twice\n      throwStubExceptions: true,\n    };\n\n    options.applyOptions = {\n      ...defaultApplyOptions,\n      ...options.applyOptions\n    };\n\n    // Attach all options to the ValidatedMethod instance\n    Object.assign(this, options);\n\n    const method = this;\n    this.connection.methods({\n      [options.name](args) {\n        // Silence audit-argument-checks since arguments are always checked when using this package\n        check(args, Match.Any);\n        const methodInvocation = this;\n\n        return method._execute(methodInvocation, args);\n      }\n    });\n  }\n\n  call(args, callback) {\n    // Accept calling with just a callback\n    if ( typeof args === 'function' ) {\n      callback = args;\n      args = {};\n    }\n\n    try {\n      return this.connection.apply(this.name, [args], this.applyOptions, callback);\n    } catch (err) {\n      if (callback) {\n        // Get errors from the stub in the same way as from the server-side method\n        callback(err);\n      } else {\n        // No callback passed, throw instead of silently failing; this is what\n        // \"normal\" Methods do if you don't pass a callback.\n        throw err;\n      }\n    }\n  }\n\n  callAsync(args) {\n\t\t//taken from the callAsync method internals which will use applyAsync with a isFromCallAsync param\n\t\t//which will flag methods as running on DDP\n\t\t//reset current method invocation and mark it as running\n\t\tif (Meteor.isClient) {\n\t\t\tDDP._CurrentMethodInvocation._set();\n\t\t\tDDP._CurrentMethodInvocation._setCallAsyncMethodRunning(true);\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst clientResultOrThenable = this.connection.applyAsync(\n\t\t\t\t\tthis.name,\n\t\t\t\t\t[args],\n\t\t\t\t\t//ensure throwStubExceptions which we need in order\n\t\t\t\t\t//to catch client exceptions and re-throw them as promise rejections\n\t\t\t\t\t//mimic callAsync through isFromCallAsync\n\t\t\t\t\t//merge with this.applyOptions\n\t\t\t\t\tObject.assign(this.applyOptions, { throwStubExceptions: true, isFromCallAsync: true }),\n\t\t\t\t\t(err, serverResult) => {\n\t\t\t\t\t\t//set the current invocation running to false as soon as server returned its\n\t\t\t\t\t\t//promise so that subsequent methods in .then's of the first method run in their\n\t\t\t\t\t\t//own context instead of thinking they are a stub for the first method\n\t\t\t\t\t\t//MethodOne.call(params)\n\t\t\t\t\t\t//.then(() => MethodTwo.call())\n\t\t\t\t\t\t//.catch(err => log(err));\n\n\t\t\t\t\t\tDDP._CurrentMethodInvocation._setCallAsyncMethodRunning(false);\n\n\t\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\t\tresolve(serverResult);\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\tisThenable = clientResultOrThenable && typeof clientResultOrThenable.then === 'function';\n\n\t\t\t\t//catch exceptions on the stub and re-route them to the promise wrapper\n\t\t\t\tif (isThenable) clientResultOrThenable.catch(err => reject(err));\n\t\t\t});\n\t\t}\n\n\t\t//when called from server, just return the promise as returned by the method\n\t\treturn this.connection.applyAsync(this.name, [args], this.applyOptions);\n  }\n\n  _execute(methodInvocation = {}, args) {\n    // Add `this.name` to reference the Method name\n    methodInvocation.name = this.name;\n\n    const validateResult = this.validate.bind(methodInvocation)(args);\n\n    if (typeof validateResult !== 'undefined') {\n      throw new Error(`Returning from validate doesn't do anything; \\\nperhaps you meant to throw an error?`);\n    }\n\n    return this.run.bind(methodInvocation)(args);\n  }\n};\n\n// Mixins get a chance to transform the arguments before they are passed to the actual Method\nfunction applyMixins(args, mixins) {\n  // Save name of the method here, so we can attach it to potential error messages\n  const { name } = args;\n\n  mixins.forEach((mixin) => {\n    args = mixin(args);\n\n    if(!Match.test(args, Object)) {\n      const functionName = mixin.toString().match(/function\\s(\\w+)/);\n      let msg = 'One of the mixins';\n\n      if(functionName) {\n        msg = `The function '${functionName[1]}'`;\n      }\n\n      throw new Error(`Error in ${name} method: ${msg} didn't return the options object.`);\n    }\n  });\n\n  return args;\n}\n"]}